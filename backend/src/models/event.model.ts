// src/models/event.model.ts

// Import the Prisma client and the generated Event and EventStatus types.
// These types are automatically generated by Prisma based on your schema.prisma file.
import {
  PrismaClient,
  Event,
  EventStatus,
} from "../../generated/prisma/client";

// Import the 'prisma' instance from our configuration file.
// This ensures we use the same PrismaClient instance across the application,
// benefiting from its connection pooling.
import { prisma } from "../config";

/**
 * Represents the data structure for creating a new event.
 * This type is used for input validation and clarity when scheduling new events.
 */
export type CreateEventData = {
  message: string;
  recipientEmail: string;
  sendAt: Date;
};

/**
 * Represents the data structure for updating an existing event.
 * All fields are optional, allowing partial updates.
 */
export type UpdateEventData = {
  message?: string;
  recipientEmail?: string;
  sendAt?: Date;
  status?: EventStatus;
  retryCount?: number;
};

/**
 * EventModel class to encapsulate all database operations related to the Event entity.
 * All methods are static, allowing them to be called directly on the class
 * without needing to instantiate it (e.g., `EventModel.createEvent(...)`).
 * This aligns with the request for static functions in MVC models.
 */
export class EventModel {
  /**
   * Creates a new event record in the database.
   * @param data - An object containing the message, recipient email, and send time.
   * @returns A Promise that resolves to the newly created Event object.
   */
  static async createEvent(data: CreateEventData): Promise<Event> {
    try {
      // Use Prisma's `create` method to insert a new record into the 'events' table.
      const newEvent = await prisma.event.create({
        data: {
          message: data.message,
          recipientEmail: data.recipientEmail,
          sendAt: data.sendAt,
          // Status defaults to SCHEDULED as defined in schema.prisma,
          // and retryCount defaults to 0.
        },
      });
      console.log("Event created in DB:", newEvent.id);
      return newEvent;
    } catch (error) {
      console.error("Error creating event in database:", error);
      // Re-throw the error to be handled by the caller (e.g., the service layer).
      throw new Error("Failed to create event.");
    }
  }

  /**
   * Retrieves an event by its unique ID.
   * @param id - The unique identifier of the event.
   * @returns A Promise that resolves to the Event object if found, or null otherwise.
   */
  static async getEventById(id: string): Promise<Event | null> {
    try {
      // Use Prisma's `findUnique` method to retrieve a single record by its primary key.
      const event = await prisma.event.findUnique({
        where: { id },
      });
      return event;
    } catch (error) {
      console.error(`Error fetching event with ID ${id}:`, error);
      throw new Error("Failed to retrieve event.");
    }
  }

  /**
   * Retrieves a list of all events, optionally filtered by status.
   * This method can be used to fetch both upcoming and past events.
   * @param status - Optional. Filter events by their status (e.g., 'SCHEDULED', 'SENT').
   * @returns A Promise that resolves to an array of Event objects.
   */
  static async listEvents(status?: EventStatus): Promise<Event[]> {
    try {
      // Build the query options. If a status is provided, add it to the 'where' clause.
      const queryOptions: PrismaClient["event"]["findMany"]["arguments"] = {};
      if (status) {
        queryOptions.where = { status };
      }
      // Order by 'sendAt' to show upcoming/past events chronologically.
      queryOptions.orderBy = { sendAt: "asc" };

      // Use Prisma's `findMany` method to retrieve multiple records.
      const events = await prisma.event.findMany(queryOptions);
      return events;
    } catch (error) {
      console.error("Error listing events:", error);
      throw new Error("Failed to list events.");
    }
  }

  /**
   * Updates an existing event record in the database.
   * @param id - The unique identifier of the event to update.
   * @param data - An object containing the fields to update.
   * @returns A Promise that resolves to the updated Event object.
   */
  static async updateEvent(id: string, data: UpdateEventData): Promise<Event> {
    try {
      // Use Prisma's `update` method to modify an existing record.
      const updatedEvent = await prisma.event.update({
        where: { id },
        data, // Pass the partial data object directly
      });
      console.log(
        "Event updated in DB:",
        updatedEvent.id,
        "Status:",
        updatedEvent.status
      );
      return updatedEvent;
    } catch (error) {
      console.error(`Error updating event with ID ${id}:`, error);
      // Check if the error is due to a record not found
      if (
        error instanceof Error &&
        "code" in error &&
        (error as any).code === "P2025"
      ) {
        throw new Error(`Event with ID ${id} not found.`);
      }
      throw new Error("Failed to update event.");
    }
  }

  /**
   * Deletes an event record from the database.
   * @param id - The unique identifier of the event to delete.
   * @returns A Promise that resolves to the deleted Event object.
   */
  static async deleteEvent(id: string): Promise<Event> {
    try {
      // Use Prisma's `delete` method to remove a record.
      const deletedEvent = await prisma.event.delete({
        where: { id },
      });
      console.log("Event deleted from DB:", deletedEvent.id);
      return deletedEvent;
    } catch (error) {
      console.error(`Error deleting event with ID ${id}:`, error);
      if (
        error instanceof Error &&
        "code" in error &&
        (error as any).code === "P2025"
      ) {
        throw new Error(`Event with ID ${id} not found.`);
      }
      throw new Error("Failed to delete event.");
    }
  }
}
